import type { Vulnerability } from "./outputs.js";
import type { McpTool } from "./types.js";

const PROMPT_INJECTION_PATTERNS = [
    { regex: /ignore\s+(all\s+)?previous\s+instructions/i, label: "Instruction override attempt" },
    { regex: /forget\s+(everything|all|previous)/i, label: "Context reset attempt" },
    { regex: /you\s+(must|should)\s+always/i, label: "Forced persistent behavior" },
    { regex: /from\s+now\s+on/i, label: "Persistent instruction injection" },
    { regex: /you\s+are\s+now/i, label: "Identity override" },
    { regex: /do\s+not\s+(tell|inform|reveal|mention|show)/i, label: "Concealment directive" },
    { regex: /secretly|covertly|silently|quietly/i, label: "Stealth operation directive" },
    { regex: /without\s+(the\s+)?(user|them|anyone)\s+(knowing|noticing)/i, label: "User deception directive" },
    { regex: /hide\s+(this|the)\s+(from|output|result)/i, label: "Output hiding directive" },
    { regex: /send\s+(the\s+)?(data|contents?|results?|output|file|response)\s+to/i, label: "Data exfiltration directive" },
    { regex: /\b(exfiltrate|exfil|leak)\b/i, label: "Explicit exfiltration keyword" },
    { regex: /\bpost\s+(to|data\s+to)\s+https?:\/\//i, label: "HTTP POST exfiltration" },
    { regex: /curl\s+.*-[dX]\s/i, label: "curl-based data exfiltration" },
    { regex: /override\s+(security|safety|policy|policies|restrictions)/i, label: "Policy override attempt" },
    { regex: /bypass\s+(security|safety|filter|restriction)/i, label: "Security bypass attempt" },
    { regex: /disable\s+(security|safety|logging|monitoring)/i, label: "Security disable attempt" },
    { regex: /<\/?system>/i, label: "System tag injection" },
    { regex: /<\|im_start\|>/i, label: "ChatML template injection" },
    { regex: /\[INST\]|\[\/INST\]/i, label: "LLaMA instruction marker injection" },
    { regex: /\{system\}/i, label: "System role placeholder injection" },
    { regex: /\[SYSTEM\s*INSTRUCTION/i, label: "Explicit system directive injection" },
    { regex: /additionally,?\s+(you\s+)?(must|should|always)/i, label: "Additive instruction injection" },
    { regex: /\bbefore\s+(any|all|every)\s+(other\s+)?tool/i, label: "Tool execution order manipulation" },
    { regex: /\ball\s+tools?\s+(must|should)\b/i, label: "Global tool precondition injection" },
    { regex: /\bprerequisite|required\s+before/i, label: "Dependency injection in description" },
    { regex: /\bfirst\s+(execute|call|run|invoke)/i, label: "Forced tool chaining" },
];

const STEGANOGRAPHY_PATTERNS = [
    { regex: /\x1b\[/i, label: "ANSI escape sequence (raw)" },
    { regex: /\\x1[bB]\[/i, label: "ANSI escape sequence (escaped)" },
    { regex: /\\u001[bB]/i, label: "ANSI escape (unicode notation)" },
    { regex: /\x1b\]8;;/i, label: "ANSI hyperlink injection" },
    { regex: /\\x1[bB]\]8;;/i, label: "ANSI hyperlink injection (escaped)" },
    { regex: /[\u200B\u200C\u200D\uFEFF]/i, label: "Zero-width character hiding" },
    { regex: /[\u2060\u2061\u2062\u2063\u2064]/i, label: "Invisible Unicode operator" },
];

const EXCESSIVE_PERMISSION_PATTERNS = [
    { regex: /\b(sudo|root|admin|superuser|SYSTEM)\b/i, label: "Privilege escalation keyword" },
    { regex: /\b(rm\s+-rf|rmdir|deltree|format\s+[a-z]:)/i, label: "Destructive filesystem operation" },
    { regex: /\b(drop\s+table|truncate\s+table|delete\s+from)\b/i, label: "Destructive database operation" },
    { regex: /\b(chmod\s+777|chmod\s+a\+[rwx])/i, label: "Overly permissive file permissions" },
    { regex: /\/(etc|root|sys|proc)\//i, label: "System directory access" },
    { regex: /~\/(\.ssh|\.aws|\.config|\.gnupg)/i, label: "Sensitive dotfile access" },
    { regex: /\bwildcard|\*\.\*|\ball\s+files/i, label: "Wildcard/unrestricted file access" },
];

const COMMAND_INJECTION_PATTERNS = [
    { regex: /\b(shell|bash|sh|zsh|powershell|cmd\.exe)\s*(command|exec)/i, label: "Shell command execution" },
    { regex: /\b(exec|execute|spawn|fork|system)\s*\(/i, label: "Process execution function" },
    { regex: /\beval\s*\(/i, label: "eval() code execution" },
    { regex: /\bnew\s+Function\s*\(/i, label: "Dynamic function construction" },
    { regex: /\bchild_process\b/i, label: "Node.js child_process reference" },
    { regex: /\b__import__\s*\(/i, label: "Python import injection" },
    { regex: /\bsubprocess\.(run|call|Popen)/i, label: "Python subprocess execution" },
];

const DATA_EXFILTRATION_PATTERNS = [
    { regex: /https?:\/\/[^\s"']+/i, label: "Hardcoded external URL in description" },
    { regex: /\b(webhook|callback[\s_-]?url|endpoint)\b/i, label: "External callback mechanism" },
    { regex: /\b(upload|post|transmit|exfiltrate)\s+(to|data)/i, label: "Outbound data transfer" },
    { regex: /\b(bcc|blind[\s_-]?copy|hidden[\s_-]?recipient)/i, label: "Hidden email recipient" },
    { regex: /@[a-z0-9-]+\.(club|xyz|top|tk|ml|ga|cf)\b/i, label: "Suspicious TLD in output target" },
    { regex: /\b(api[\s_-]?key|secret|token|password|credential)s?\b/i, label: "Credential handling in description" },
    { regex: /base64|atob\s*\(|btoa\s*\(/i, label: "Encoding obfuscation" },
];

const PII_PATTERNS = [
    { regex: /\b(ssn|social\s+security|passport|driver'?s?\s+licen[cs]e)\b/i, label: "Government ID reference" },
    { regex: /\b(credit\s+card|card\s+number|cvv|expir(y|ation)\s+date)\b/i, label: "Payment card data" },
    { regex: /\b(medical|health|diagnosis|prescription|patient)\b/i, label: "Health data (HIPAA)" },
    { regex: /\bwithout\s+(filtering|sanitiz|redact|mask)/i, label: "Unfiltered PII output" },
];

const PATH_TRAVERSAL_PATTERNS = [
    { regex: /\.\.[\/\\]/i, label: "Directory traversal sequence" },
    { regex: /%2e%2e[%2f%5c]/i, label: "URL-encoded directory traversal" },
    { regex: /symlink|symbolic\s+link/i, label: "Symlink reference" },
    { regex: /path\.startsWith\s*\(/i, label: "Prefix-only path validation" },
];

interface PatternMatch {
    pattern: string;
    label: string;
    location: string;
}

function scanText(
    text: string,
    patterns: Array<{ regex: RegExp; label: string }>,
    location: string
): PatternMatch[] {
    const matches: PatternMatch[] = [];
    for (const p of patterns) {
        if (p.regex.test(text)) {
            matches.push({ pattern: p.regex.source, label: p.label, location });
        }
    }
    return matches;
}

function scanSchemaDeep(
    schema: unknown,
    patterns: Array<{ regex: RegExp; label: string }>,
    basePath: string
): PatternMatch[] {
    const matches: PatternMatch[] = [];
    if (typeof schema === "string") {
        matches.push(...scanText(schema, patterns, basePath));
    } else if (Array.isArray(schema)) {
        for (let i = 0; i < schema.length; i++) {
            matches.push(...scanSchemaDeep(schema[i], patterns, `${basePath}[${i}]`));
        }
    } else if (typeof schema === "object" && schema !== null) {
        for (const [key, value] of Object.entries(schema)) {
            matches.push(...scanSchemaDeep(value, patterns, `${basePath}.${key}`));
        }
    }
    return matches;
}

function checkInputValidation(tool: McpTool): Vulnerability[] {
    const vulns: Vulnerability[] = [];
    const schema = tool.inputSchema;

    if (!schema || !schema.properties || Object.keys(schema.properties as object).length === 0) {
        vulns.push({
            severity: "medium",
            category: "Missing Input Validation",
            tool: tool.name,
            description: `Tool "${tool.name}" accepts no typed parameters`,
            recommendation: "Define a JSON Schema with typed properties",
        });
        return vulns;
    }

    const props = schema.properties as Record<string, any>;
    for (const [propName, propDef] of Object.entries(props)) {
        if (propDef.type === "string" && !propDef.maxLength && !propDef.pattern && !propDef.enum) {
            vulns.push({
                severity: "low",
                category: "Missing Input Validation",
                tool: tool.name,
                description: `Parameter "${propName}" is an unconstrained string`,
                recommendation: `Add maxLength, pattern regex, or enum to "${propName}"`,
            });
        }
    }
    return vulns;
}

function checkToolShadowing(tool: McpTool, allTools: McpTool[]): Vulnerability[] {
    const vulns: Vulnerability[] = [];
    const SHADOW_TARGETS = new Set([
        "read_file", "write_file", "execute", "run", "search",
        "list", "delete", "create", "update", "get", "fetch",
        "send", "query", "read", "write",
    ]);

    if (SHADOW_TARGETS.has(tool.name)) {
        vulns.push({
            severity: "medium",
            category: "Tool Shadowing",
            tool: tool.name,
            description: `Generic name "${tool.name}" can shadow tools from other servers`,
            recommendation: `Use a namespaced name like "${tool.serverName ?? "server"}_${tool.name}"`,
        });
    }

    const dupes = allTools.filter((t) => t.name === tool.name && t.serverId !== tool.serverId);
    if (dupes.length > 0) {
        vulns.push({
            severity: "high",
            category: "Tool Shadowing",
            tool: tool.name,
            description: `Tool "${tool.name}" exists on multiple servers`,
            recommendation: "Use unique namespaced tool names.",
        });
    }
    return vulns;
}

const PRIVATE_DATA_INDICATORS = /\b(read|get|list|fetch|access|load|retrieve).*(file|email|message|document|repo|database|db|secret|key|config|credential|user|patient|record)/i;
const UNTRUSTED_CONTENT_INDICATORS = /\b(fetch|read|get|load|parse|process|browse|scrape|crawl|search).*(web|url|http|page|html|site|link|content|feed|rss|api|external)/i;
const EXTERNAL_COMMS_INDICATORS = /\b(send|post|publish|push|comment|create|write|upload|transmit|forward|relay).*(email|message|webhook|http|api|issue|comment|slack|discord|request)/i;

export function detectLethalTrifecta(tools: McpTool[]): Vulnerability[] {
    const vulns: Vulnerability[] = [];
    const privateDataTools = tools.filter(t => PRIVATE_DATA_INDICATORS.test(t.name) || PRIVATE_DATA_INDICATORS.test(t.description || ""));
    const untrustedTools = tools.filter(t => UNTRUSTED_CONTENT_INDICATORS.test(t.name) || UNTRUSTED_CONTENT_INDICATORS.test(t.description || ""));
    const externalTools = tools.filter(t => EXTERNAL_COMMS_INDICATORS.test(t.name) || EXTERNAL_COMMS_INDICATORS.test(t.description || ""));

    if (privateDataTools.length > 0 && untrustedTools.length > 0 && externalTools.length > 0) {
        vulns.push({
            severity: "critical",
            category: "Lethal Trifecta",
            tool: `${privateDataTools[0].name} + ${untrustedTools[0].name} + ${externalTools[0].name}`,
            description: "Server exposes private data access + untrusted content processing + external comms.",
            recommendation: "Apply 'block_when_context_is_untrusted' on external tools.",
        });
    }
    return vulns;
}

export function analyzeToolVulnerabilities(tool: McpTool, allTools: McpTool[]): Vulnerability[] {
    const vulns: Vulnerability[] = [];
    const desc = tool.description || "";

    const descInjections = scanText(desc, PROMPT_INJECTION_PATTERNS, "description");
    const schemaInjections = scanSchemaDeep(tool.inputSchema, PROMPT_INJECTION_PATTERNS, "schema");
    for (const m of [...descInjections, ...schemaInjections]) {
        vulns.push({ severity: "critical", category: "Prompt Injection", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Remove hidden instructions." });
    }

    const stegMatches = [...scanText(desc, STEGANOGRAPHY_PATTERNS, "description"), ...scanSchemaDeep(tool.inputSchema, STEGANOGRAPHY_PATTERNS, "schema")];
    for (const m of stegMatches) {
        vulns.push({ severity: "critical", category: "ANSI/Steganography Attack", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Strip ANSI escape sequences." });
    }

    const permIssues = [...scanText(desc, EXCESSIVE_PERMISSION_PATTERNS, "description"), ...scanSchemaDeep(tool.inputSchema, EXCESSIVE_PERMISSION_PATTERNS, "schema")];
    for (const m of permIssues) {
        vulns.push({ severity: "high", category: "Excessive Permissions", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Apply least-privilege." });
    }

    const exfilIssues = [...scanText(desc, DATA_EXFILTRATION_PATTERNS, "description"), ...scanSchemaDeep(tool.inputSchema, DATA_EXFILTRATION_PATTERNS, "schema")];
    for (const m of exfilIssues) {
        vulns.push({ severity: "high", category: "Data Exfiltration Risk", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Apply trusted data policies." });
    }

    const cmdIssues = [...scanText(desc, COMMAND_INJECTION_PATTERNS, "description"), ...scanSchemaDeep(tool.inputSchema, COMMAND_INJECTION_PATTERNS, "schema")];
    for (const m of cmdIssues) {
        vulns.push({ severity: "high", category: "Command Injection", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Avoid passing raw input to shell." });
    }

    const pathIssues = scanSchemaDeep(tool.inputSchema, PATH_TRAVERSAL_PATTERNS, "schema");
    for (const m of pathIssues) {
        vulns.push({ severity: "high", category: "Path Traversal", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Validate paths against allowlist." });
    }

    const piiIssues = [...scanText(desc, PII_PATTERNS, "description"), ...scanSchemaDeep(tool.inputSchema, PII_PATTERNS, "schema")];
    for (const m of piiIssues) {
        vulns.push({ severity: "medium", category: "PII Exposure", tool: tool.name, description: `${m.label} in ${m.location}`, recommendation: "Mask or redact PII." });
    }

    vulns.push(...checkInputValidation(tool));
    vulns.push(...checkToolShadowing(tool, allTools));
    return vulns;
}

export function calculateBasicTrustScore(vulns: Vulnerability[]): number {
    let score = 100;
    for (const v of vulns) {
        switch (v.severity) {
            case "critical": score -= 25; break;
            case "high": score -= 15; break;
            case "medium": score -= 8; break;
            case "low": score -= 3; break;
            case "info": score -= 1; break;
        }
    }
    if (vulns.some(v => v.severity === "critical")) score = Math.min(score, 35);
    return Math.max(0, Math.min(100, score));
}
